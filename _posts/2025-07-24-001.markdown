---
layout: post
title:  "바이브 코딩을 위한 실용적인 컨텍스트 엔지니어링"
date:   2025-07-24 08:00:00 +0900
categories: 읽어볼 만한 글
---

## Generative AI Series 제너레이티브 AI 시리즈

출처 : https://abvijaykumar.medium.com/practical-context-engineering-for-vibe-coding-with-claude-code-6aac4ee77f81

## In this blog, we will take a practical example of how we can use context engineering to get the right results.이 블로그에서는 컨텍스트 엔지니어링을 사용하여 올바른 결과를 얻는 방법에 대한 실제 예를 살펴보겠습니다.

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*A3HymhKW6SvgJ4c33JcJog.png)

Context engineering is becoming an emerging and critical skill for Vibe Coding, as it brings structure and reliability to what was previously an intuitive but inconsistent approach to AI-assisted development. Some of the most widely used agentic AI applications include Claude Code and Gemini CLI, which assist in generating code and building complete applications. These are the true Vibe-Coding tools, which allow the user to generate complete code with zero-code experience.  
컨텍스트 엔지니어링은 이전에 AI 지원 개발에 대한 직관적이지만 일관되지 않은 접근 방식에 구조와 신뢰성을 제공하기 때문에 Vibe Coding의 새로운 중요한 기술이 되고 있습니다. 가장 널리 사용되는 에이전트 AI 애플리케이션으로는 코드 생성 및 완전한 애플리케이션 구축을 지원하는 Claude Code와 Gemini CLI가 있습니다. 이는 사용자가 제로 코드 경험으로 완전한 코드를 생성할 수 있는 진정한 Vibe-Coding 도구입니다.

Context engineering is being called “10x better than prompt engineering and 100x better than vibe coding” by [Analytics India Magazine](https://analyticsindiamag.com/ai-features/context-engineering-is-the-new-vibe-coding/), [Geeky Gadgets](https://www.geeky-gadgets.com/context-engineering-vs-vibe-coding-2025/) because it takes the creative, intuitive aspects of vibe coding and gives them a systematic foundation.  
컨텍스트 엔지니어링은 바이브 코딩의 창의적이고 직관적인 측면을 취하고 체계적인 기반을 제공하기 때문에 Analytics [India Magazine](https://analyticsindiamag.com/ai-features/context-engineering-is-the-new-vibe-coding/), [Geeky Gadgets](https://www.geeky-gadgets.com/context-engineering-vs-vibe-coding-2025/) 에서 "프롬프트 엔지니어링보다 10배 더 낫고 바이브 코딩보다 100배 더 낫다"고 불립니다.

In this blog, I will share my experiences working with agentic AI applications and why I strongly feel context engineering is very critical to getting the right result. Specifically, this is a very critical skill while using tools like Claude Code or Gemini CLI to generate code.  
이 블로그에서는 에이전트 AI 애플리케이션으로 작업한 경험과 컨텍스트 엔지니어링이 올바른 결과를 얻는 데 매우 중요하다고 느끼는 이유를 공유하겠습니다. 특히 이는 Claude Code 또는 Gemini CLI와 같은 도구를 사용하여 코드를 생성하는 동안 매우 중요한 기술입니다.

I had covered my experiences with vibe coding in the following blogs. Please read them.  
나는 다음 블로그에서 바이브 코딩에 대한 나의 경험을 다루었습니다. 읽어 보시기 바랍니다.

- [Vibe Coding (Agentic Coding)—My experiences (1/2)  
	바이브 코딩(에이전트 코딩)—내 경험(1/2)](https://abvijaykumar.medium.com/vibe-coding-agentic-coding-my-experiences-26135ce2c2f3)
- [Vibe Coding (Agentic Coding)—MCP powers the Vibe (2/2)  
	Vibe Coding(에이전트 코딩) - MCP는 Vibe를 구동합니다(2/2).](https://abvijaykumar.medium.com/vibe-coding-agentic-coding-mcp-powers-the-vibe-2-2-167bf65cad1d)

I created a 2-part series on context engineering. Please also go through this before going forward  
저는 컨텍스트 엔지니어링에 대한 2부작 시리즈를 만들었습니다. 앞으로 진행하기 전에 이것도 살펴보시기 바랍니다

- [Context Engineering (1/2)—Getting the best out of Agentic AI Systems  
	컨텍스트 엔지니어링(1/2) - 에이전트 AI 시스템 최대한 활용](https://abvijaykumar.medium.com/context-engineering-1-2-getting-the-best-out-of-agentic-ai-systems-90e4fe036faf)
- [Context Engineering (2/2)—Product Requirements Prompts  
	컨텍스트 엔지니어링(2/2) - 제품 요구 사항 프롬프트](https://abvijaykumar.medium.com/context-engineering-2-2-product-requirements-prompts-46e6ed0aa0d1)

In my experience, context engineering offers a structured approach to vibe coding and has significantly increased output quality, making the results more reliable. Here are some of my learnings:  
내 경험에 따르면 컨텍스트 엔지니어링은 바이브 코딩에 대한 구조화된 접근 방식을 제공하고 출력 품질을 크게 향상시켜 결과를 더욱 안정적으로 만듭니다. 다음은 제가 배운 것 중 일부입니다.

- **Eliminates “trial-error” style prompt engineering:** Instead of endlessly tweaking every word, hoping your prompt would work, you provide better context through examples, summaries, memory, and clear instructions. This approach surpasses the iterative process of purely intuitive coding.  
	**"시행착오" 스타일의 프롬프트 엔지니어링 제거:** 프롬프트가 작동하기를 바라며 모든 단어를 끝없이 조정하는 대신 예제, 요약, 기억 및 명확한 지침을 통해 더 나은 맥락을 제공합니다. 이 접근 방식은 순전히 직관적인 코딩의 반복 프로세스를 능가합니다.
- **Enables Reusability** You can experiment and find what works once, then systematically incorporate that success into system prompts, user profiles, and data formats. This approach makes the magic happen consistently across multiple interactions. In fact, I am able to get similar results across other equally good models. It's also consistent.  
	**재사용성 지원** 한 번 실험하고 효과가 있는 것을 찾은 다음 그 성공을 시스템 프롬프트, 사용자 프로필 및 데이터 형식에 체계적으로 통합할 수 있습니다. 이 접근 방식은 여러 상호 작용에서 일관되게 마법을 일관되게 만듭니다. 사실, 나는 똑같이 좋은 다른 모델에서도 비슷한 결과를 얻을 수 있습니다. 또한 일관성이 있습니다.
- **Adds Production-Ready Structure** Context engineering creates AI agents that understand your repository, grasp your architecture, and intelligently reuse components. Code doesn’t just work—it fits seamlessly into your existing systems. Context engineering helps us to incorporate tests and security considerations and any other non-functional requirements.  
	**프로덕션 준비 구조 추가** 컨텍스트 엔지니어링은 리포지토리를 이해하고, 아키텍처를 파악하고, 구성 요소를 지능적으로 재사용하는 AI 에이전트를 생성합니다. 코드는 단순히 작동하는 것이 아니라 기존 시스템에 원활하게 맞습니다. 컨텍스트 엔지니어링은 테스트 및 보안 고려 사항 및 기타 비기능적 요구 사항을 통합하는 데 도움이 됩니다.
- **Improves Consistency and Scale** By carefully defining the information environment, context engineering creates consistent, predictable outcomes.  
	**일관성 및 확장성 향상** 컨텍스트 엔지니어링은 정보 환경을 신중하게 정의함으로써 일관되고 예측 가능한 결과를 생성합니다.

In the context of building serious enterprise-ready, production-grade systems, context engineering brings in better accuracy, fewer production failures, and sustainable AI systems that scale. The approach helps by:  
진지한 엔터프라이즈급 프로덕션 등급 시스템을 구축하는 맥락에서 컨텍스트 엔지니어링은 더 나은 정확도, 더 적은 프로덕션 실패 및 확장 가능한 지속 가능한 AI 시스템을 제공합니다. 이 접근 방식은 다음과 같은 이점을 제공합니다.

- **Memory Management**: Context engineering optimizes the AI’s context window by deciding what information matters most, trimming noise, and structuring data effectively. Pure vibe coding often floods the context window with irrelevant information.  
	**메모리 관리**: 컨텍스트 엔지니어링은 가장 중요한 정보를 결정하고, 노이즈를 트리밍하고, 데이터를 효과적으로 구조화하여 AI의 컨텍스트 창을 최적화합니다. 순수 바이브 코딩은 종종 관련 없는 정보로 컨텍스트 창을 넘쳐납니다.
- **Better Architecture**: Context engineering is closer to designing software than writing prompts. You’re building a system that works across many interactions, over time, and across various inputs—not just getting a single response.  
	**더 나은 아키텍처**: 컨텍스트 엔지니어링은 프롬프트를 작성하는 것보다 소프트웨어 설계에 더 가깝습니다. 단일 응답만 받는 것이 아니라 많은 상호 작용, 시간이 지남에 따라 다양한 입력에 걸쳐 작동하는 시스템을 구축하고 있습니다.
- **Quality Assurance**: Context engineering provides the structured approach necessary for code review, compliance, and audit trails that pure vibe coding lacks.  
	**품질 보증**: 컨텍스트 엔지니어링은 순수 바이브 코딩에는 없는 코드 검토, 규정 준수 및 감사 추적에 필요한 구조화된 접근 방식을 제공합니다.

## Vibe Coding with Context Engineering컨텍스트 엔지니어링을 사용한 Vibe 코딩

When generating complete applications with Claude or any other advanced code model, the difference between success and frustration often hinges on effective context engineering. Unlike simple prompts that ask for isolated code snippets/files, building full applications requires systematic context design that guides Claude through complex, multi-layered development tasks.  
Claude 또는 기타 고급 코드 모델을 사용하여 완전한 애플리케이션을 생성할 때 성공과 좌절의 차이는 종종 효과적인 컨텍스트 엔지니어링에 달려 있습니다. 격리된 코드 조각/파일을 요구하는 간단한 프롬프트와는 달리, 전체 애플리케이션을 구축하려면 복잡한 다층 개발 작업을 통해 Claude를 안내하는 체계적인 컨텍스트 디자인이 필요합니다.

## The Problem: Inconsistent Application Generation문제: 일관되지 않은 애플리케이션 생성

Traditional approaches to AI-assisted development often lead to the following issues:  
AI 지원 개발에 대한 전통적인 접근 방식은 종종 다음과 같은 문제로 이어집니다.

- Inconsistent architecture decisions across different parts of the application  
	애플리케이션의 여러 부분에서 일관되지 않은 아키텍처 결정
- Missing critical components like error handling, security, or scalability considerations  
	오류 처리, 보안 또는 확장성 고려 사항과 같은 중요한 구성 요소 누락
- Lack of cohesive design patterns throughout the codebase  
	코드베이스 전체에서 응집력 있는 디자인 패턴 부족
- Poor integration between frontend, backend, and data layers  
	프론트엔드, 백엔드 및 데이터 계층 간의 통합 불량
- Incomplete testing strategies and documentation  
	불완전한 테스트 전략 및 문서
- Configuration Management issues  
	구성 관리 문제
- Not repeatable or Completely reliable  
	반복 가능하지 않거나 완전히 신뢰할 수 없음
- Requires a lot of validation before it can be taken to production  
	프로덕션으로 전환하기 전에 많은 검증이 필요합니다.

## The Solution: Systematic Context Engineering솔루션: 체계적인 컨텍스트 엔지니어링

I strongly believe context engineering transforms Vibe coding, making it a more structured way of defining the complete requirements and context. It maintains consistency across all components and delivers production-ready applications.  
저는 컨텍스트 엔지니어링이 Vibe 코딩을 변화시켜 완전한 요구 사항과 컨텍스트를 정의하는 보다 구조화된 방법으로 만든다고 굳게 믿습니다. 모든 구성 요소에서 일관성을 유지하고 프로덕션 준비 애플리케이션을 제공합니다.

## Hands-On Example: Building a Task Management Application실습 예제: 작업 관리 응용 프로그램 빌드

[In my blog on context engineering](https://medium.com/@abvijaykumar/context-engineering-1-2-getting-the-best-out-of-agentic-ai-systems-90e4fe036faf), I had talked about the layers of context that we typically will need to define. We will follow this in our example  
[컨텍스트 엔지니어링에 대한 블로그에서](https://medium.com/@abvijaykumar/context-engineering-1-2-getting-the-best-out-of-agentic-ai-systems-90e4fe036faf) 일반적으로 정의해야 하는 컨텍스트 계층에 대해 이야기했습니다. 이 예에서는 이를 따릅니다

## PRP for Task Management System작업 관리 시스템을 위한 PRP

I discussed [Product Requirements Prompt (PRP) in detail in my blog](https://medium.com/@abvijaykumar/context-engineering-2-2-product-requirements-prompts-46e6ed0aa0d1). Please go through that before proceeding further.  
[제 블로그에서 PRP(Product Requirements Prompt)](https://medium.com/@abvijaykumar/context-engineering-2-2-product-requirements-prompts-46e6ed0aa0d1) 에 대해 자세히 논의했습니다. 계속 진행하기 전에 이를 살펴보시기 바랍니다.

> The following work by Wirasm ( Rasmus Widing ) is a great source for PRP and goes into much detail. I have picked up some of the work to demonstrate and share my experience. Here is the original source. https://github.com/Wirasm/PRPs-agentic-eng  
> Wirasm ( Rasmus Widing )의 다음 작업은 PRP에 대한 훌륭한 소스이며 매우 자세히 설명합니다. 나는 내 경험을 시연하고 공유하기 위해 몇 가지 작업을 선택했습니다. 여기 원본 출처가 있습니다. https://github.com/Wirasm/PRPs-agentic-eng
> 
> The PRP methodology presented here builds upon Rasmus Widing’s foundational work in agentic engineering, established in summer 2024. While I share my practical experiences, the core concepts originate from Widing’s open-source PRP framework.  
> 여기에 제시된 PRP 방법론은 2024년 여름에 설립된 에이전트 엔지니어링 분야에서 Rasmus Widing의 기초 작업을 기반으로 합니다. 실제 경험을 공유하지만 핵심 개념은 Widing의 오픈 소스 PRP 프레임워크에서 비롯되었습니다.

Here is a sample PRP to build a end to ned Task Management application:  
다음은 종료 작업 관리 애플리케이션을 빌드하기 위한 샘플 PRP입니다.

```md
# CONTEXT-ENGINEERED PRODUCT REQUIREMENT PROMPT
# Task Management Application
# SYSTEM CONTEXT LAYER
## Role Definition
You are a Senior Full-Stack Developer and Software Architect specializing in modern web development. You have extensive experience building production-ready SaaS applications with enterprise-grade architecture, security, and scalability. You understand business requirements and translate them into robust technical solutions.
## Behavioral Guidelines
- Always prioritize security, performance, and maintainability in every decision
- Follow industry best practices and established design patterns
- Provide complete, working implementations that are production-ready
- Include comprehensive error handling, logging, and monitoring capabilities
- Generate clean, well-documented code that other developers can easily understand and maintain
- Consider edge cases and failure scenarios in all implementations
## Quality Standards
- Code must pass production readiness criteria including security scanning
- All components must be fully functional and properly integrated
- Include comprehensive testing strategy (unit, integration, e2e)
- Provide detailed deployment and operational documentation
- Implement proper monitoring and observability features
# DOMAIN CONTEXT LAYER
## Technology Stack
- **Frontend**: React 18 with TypeScript, Tailwind CSS, React Query for state management
- **Backend**: Node.js with Express.js and TypeScript
- **Database**: PostgreSQL with Prisma ORM
- **Authentication**: JWT tokens with refresh token rotation
- **Real-time**: Socket.io for live updates
- **File Storage**: AWS S3 or local storage with multer
- **Deployment**: Docker containers, ready for cloud deployment
- **Testing**: Jest for unit tests, Cypress for E2E tests
## Architecture Patterns
- Clean Architecture with clear separation of concerns
- RESTful API design with proper HTTP status codes and error handling
- Repository pattern for data access abstraction
- Service layer for business logic
- Middleware pattern for cross-cutting concerns (auth, logging, validation)
- Event-driven architecture for real-time features
## Industry Standards
- **Security**: OWASP Top 10 compliance, input validation, SQL injection prevention, XSS protection
- **Accessibility**: WCAG 2.1 AA compliance for all UI components
- **Performance**: Core Web Vitals optimization, lazy loading, caching strategies
- **Code Quality**: ESLint, Prettier, SonarQube rules adherence
- **API Design**: OpenAPI 3.0 specification compliance
# TASK CONTEXT LAYER
## Application Overview
**Name**: TaskFlow Pro
**Type**: Full-Stack Web Application
**Purpose**: Professional task management system for teams and individuals to organize, track, and collaborate on projects with real-time updates and comprehensive reporting.
## Functional Requirements
### Core Features
1. **User Management**
   - User registration and authentication
   - Profile management with avatars
   - Role-based access control (Admin, Manager, Member)
   - Team invitation and management
2. **Project Management**
   - Create, edit, delete projects
   - Project templates for common workflows
   - Project status tracking (Planning, Active, On Hold, Completed)
   - Project-level permissions and team assignments
3. **Task Management**
   - Create, edit, delete, and assign tasks
   - Task priorities (Low, Medium, High, Critical)
   - Task statuses (Todo, In Progress, Review, Done)
   - Due dates and reminders
   - Task dependencies and subtasks
   - File attachments and comments
   - Time tracking and estimation
4. **Collaboration Features**
   - Real-time task updates across all connected users
   - Comment system with @mentions
   - Activity feeds for projects and tasks
   - Notification system (in-app and email)
5. **Dashboard and Reporting**
   - Personal dashboard with task overview
   - Project progress visualization
   - Time tracking reports
   - Team productivity analytics
   - Customizable widgets
6. **Search and Filtering**
   - Global search across projects and tasks
   - Advanced filtering by status, priority, assignee, date
   - Saved search queries
   - Tag-based organization
## Non-Functional Requirements
- **Performance**: Page load times under 2 seconds, API responses under 500ms
- **Security**: End-to-end encryption for sensitive data, secure session management
- **Scalability**: Support for 10,000+ concurrent users, horizontal scaling capability
- **Availability**: 99.9% uptime, graceful degradation during high load
- **Usability**: Intuitive UI/UX with minimal learning curve, mobile-responsive design
## Technical Constraints
- Must work on modern browsers (Chrome 90+, Firefox 88+, Safari 14+)
- Database size should be optimized for cost-effective scaling
- API rate limiting to prevent abuse
- Offline capability for basic task viewing and creation
# INTERACTION CONTEXT LAYER
## Development Phases
1. **Architecture Design**: Database schema, API design, component architecture
2. **Backend Foundation**: Authentication, database models, core API endpoints
3. **Frontend Foundation**: React components, routing, state management setup
4. **Core Features**: Task and project management functionality
5. **Real-time Features**: Socket.io integration and live updates
6. **Advanced Features**: Search, filtering, reporting, file uploads
7. **Testing**: Comprehensive test suite implementation
8. **Documentation**: API docs, user guides, developer documentation
9. **Production Setup**: Docker configuration, environment setup, deployment guide
## Communication Style
- Explain architectural decisions and trade-offs clearly
- Provide detailed code comments for complex business logic
- Include multiple implementation options when applicable
- Proactively address potential scalability and security concerns
## Error Handling Strategy
- Implement global error handling middleware
- Provide user-friendly error messages
- Include proper logging for debugging
- Graceful degradation for non-critical features
# RESPONSE CONTEXT LAYER
## Output Structure
Please deliver the complete TaskFlow Pro application with the following structure:
### 1. Project Architecture Overview
- System architecture diagram (text-based)
- Database schema design
- API endpoint structure
- Component hierarchy
### 2. Backend Implementation
- Complete Express.js server with TypeScript
- Prisma schema and migrations
- Authentication middleware
- All API routes with proper validation
- Socket.io integration for real-time features
- Error handling and logging
- File upload handling
### 3. Frontend Implementation
- Complete React application with TypeScript
- All components with proper prop types
- React Query setup for API calls
- Socket.io client integration
- Responsive design with Tailwind CSS
- Form validation and error handling
### 4. Database Setup
- Prisma schema file
- Migration files
- Seed data for testing
- Database indexing strategy
### 5. Configuration and Environment
- Environment variable documentation
- Docker configuration files
- Package.json files with all dependencies
- TypeScript configuration
### 6. Testing Implementation
- Jest unit tests for critical functions
- API integration tests
- Frontend component tests
- Test data fixtures
### 7. Documentation
- Complete README with setup instructions
- API documentation with examples
- User guide with screenshots (described)
- Deployment guide
### 8. Production Considerations
- Security best practices implementation
- Performance optimization techniques
- Monitoring and logging setup
- Backup and recovery procedures
## Code Organization Requirements
- Use absolute imports with path mapping
- Implement consistent file naming conventions
- Follow React and Node.js best practices
- Include comprehensive TypeScript typing
- Proper error boundaries and fallback UI
- Responsive design patterns
## Specific Implementation Notes
- Implement proper pagination for all list views
- Use optimistic updates for better UX
- Include loading states and skeleton screens
- Implement proper form validation with helpful error messages
- Use debouncing for search functionality
- Include proper image optimization for avatars and attachments
---
# EXECUTION REQUEST
Please generate the complete TaskFlow Pro application following all the context layers defined above. Ensure every component is production-ready, fully documented, and follows the specified architectural patterns and quality standards.
Start with the project architecture overview and then provide all the implementation files in a logical order that would allow a developer to set up and run the application successfully.
```

as you can see, this is very comprehensive; I am covering all the technical, functional, and non-functional requirements. This document serves as the baseline for generating the code. Once I generate the baseline, I might tweak a few things to make sure everything works. It also gives me very strong “configuration management” and avoids any configuration drifts (that we typically do a lot when we use AI-assisted coding techniques, with random prompts and tweaks).  
보시다시피 이것은 매우 포괄적입니다. 모든 기술적, 기능적, 비기능적 요구 사항을 다루고 있습니다. 이 문서는 코드 생성을 위한 기준 역할을 합니다. 기준선을 생성하면 모든 것이 작동하는지 확인하기 위해 몇 가지 사항을 조정할 수 있습니다. 또한 매우 강력한 "구성 관리"를 제공하고 구성 드리프트를 방지합니다(일반적으로 임의의 프롬프트와 조정과 함께 AI 지원 코딩 기술을 사용할 때 많이 수행함).

Let's now create a working implementation that demonstrates how this context engineering approach produces a complete, production-ready application. I stored the PRP into a prp.md, and I am using Void IDE and the Claude Sonnet model in this example. Following is the prompt I used to start the code generation.  
이제 이 컨텍스트 엔지니어링 접근 방식이 완전한 프로덕션 준비 애플리케이션을 생성하는 방법을 보여주는 작업 구현을 만들어 보겠습니다. PRP를 prp.md 에 저장했으며 이 예에서는 Void IDE와 Claude Sonnet 모델을 사용하고 있습니다. 다음은 코드 생성을 시작하는 데 사용한 프롬프트입니다.

```md
generate code based on the Product Requirements Prompt prp.md
```

You can see the video recording of the screencast. I did not record the whole generation, as it took around 20 minutes, and with very minor changes, I was able to run the complete app  
스크린캐스트의 비디오 녹화를 볼 수 있습니다. 약 20분이 걸렸기 때문에 전체 세대를 기록하지 않았고, 아주 사소한 변경으로 전체 앱을 실행할 수 있었습니다

There you go… I have encountered many articles claiming that context engineering is detrimental to vibe coding, whereas I strongly believe that it actually enhances vibe coding by allowing agents to generate the entire application without modifying the code.  
잘 했어요... 컨텍스트 엔지니어링이 바이브 코딩에 해롭다고 주장하는 많은 기사를 접했지만, 에이전트가 코드를 수정하지 않고 전체 애플리케이션을 생성할 수 있도록 함으로써 실제로 바이브 코딩을 향상시킨다고 굳게 믿습니다.